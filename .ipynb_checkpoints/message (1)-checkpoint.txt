#include "ros/ros.h"
#include <tiago_iaslab_simulation/Objs.h>
#include <cstdlib>
#include <actionlib/client/simple_action_client.h>
#include <actionlib/client/terminal_state.h>
#include <ir2324_group_40/actAction.h>
#include <string>
#include <cstdio>
#include <iostream>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2/utils.h>
#include <string.h>
#include <ir2324_group_40_a2/positions.h>

#include <moveit/move_group_interface/move_group_interface.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>
#include <moveit_msgs/DisplayRobotState.h>
#include <moveit_msgs/DisplayTrajectory.h>
#include <moveit_msgs/AttachedCollisionObject.h>
#include <moveit_msgs/CollisionObject.h>
#include <moveit_visual_tools/moveit_visual_tools.h>

typedef actionlib::SimpleActionClient<ir2324_group_40::actAction> actionClient;

//save coordinates of 
std::vector<double> X_ = {0, 8.25, 8.25, 8.25};
std::vector<double> Y_ = {0, -2.25, -2.25, -2.25};
std::vector<double> A_ = {0,-M_PI/2, -M_PI/2, -M_PI/2};

//print feedback to screen
void feedbackCallback(const ir2324_group_40::actFeedbackConstPtr& feedback){
	switch(feedback->status){
		case 0:
			ROS_INFO("Status: STOPPED");
		break;
		case 1:
			ROS_INFO("Status: MOVING");
		break;
		case 2:
			ROS_INFO("Status: DETECTING");
		break;
		case 3:
			ROS_INFO("Status: FINISHING");
		break;
			ROS_INFO("BAD STATUS");
	}
}

//print result to screen
void doneCallback(const actionlib::SimpleClientGoalState& state, const ir2324_group_40::actResultConstPtr& result) {
    ROS_INFO("Server: Finished in state [%s]", state.toString().c_str());
}

int callHuman(ros::NodeHandle& n){
	ros::ServiceClient client = n.serviceClient<tiago_iaslab_simulation::Objs>("/human_objects_srv");
	tiago_iaslab_simulation::Objs srv;
	srv.request.ready=true;
	srv.request.all_objs=false;
	if (client.call(srv)){
		ROS_INFO("ID: %d", srv.response.ids[0]);
		return srv.response.ids[0];
	}
	else{
		ROS_ERROR("Failed to get ids");
		return -1;
	}
}

void move(double x, double y, double angle){
	actionlib::SimpleActionClient<ir2324_group_40::actAction> ac("proxy_server", true);
	ROS_INFO("Waiting for action proxy to start.");
	ac.waitForServer(); //will wait for infinite time
	
	ROS_INFO("Action proxy started, sending goal.");
	ir2324_group_40::actGoal goal;
	
	goal.x_=x;
	goal.y_=y;
	goal.angle=angle;
	goal.detect_obs = false;

	ac.sendGoal(goal, doneCallback, actionClient::SimpleActiveCallback(), boost::bind(&feedbackCallback, _1));

	ac.waitForResult();

}

moveit_msgs::CollisionObject addCollision(float x, float y, float z, float w,
				moveit::planning_interface::MoveGroupInterface &move_group, 
				moveit::planning_interface::PlanningSceneInterface &planning_scene_interface){
	
	moveit_msgs::CollisionObject collision_object;
	collision_object.header.frame_id = move_group.getPlanningFrame();
	static int count=0;
	collision_object.id = "box"+std::to_string(count);
	count++;

	shape_msgs::SolidPrimitive primitive;
	primitive.type = primitive.BOX;
	primitive.dimensions.resize(3);
	primitive.dimensions[0] = 0.05;	//dimensioni della collision box
	primitive.dimensions[1] = 0.05;
	primitive.dimensions[2] = 0.1;
	
	geometry_msgs::Pose box_pose;	//posizioni della collision box
	box_pose.orientation.w = w;
	box_pose.position.x = x;
	box_pose.position.y = y;
	box_pose.position.z = z;

	collision_object.primitives.push_back(primitive);
	collision_object.primitive_poses.push_back(box_pose);
	collision_object.operation = collision_object.ADD;

	std::vector<moveit_msgs::CollisionObject> collision_objects;
	collision_objects.push_back(collision_object);

	ROS_INFO_NAMED("tutorial", "Add an object into the world");
	planning_scene_interface.addCollisionObjects(collision_objects);

	//visualization
	namespace rvt = rviz_visual_tools;
	moveit_visual_tools::MoveItVisualTools visual_tools("arm_link0");
	visual_tools.deleteAllMarkers();

	// Remote control is an introspection tool that allows users to step through a high level script
	// via buttons and keyboard shortcuts in RViz
	visual_tools.loadRemoteControl();

	// RViz provides many types of markers, in this demo we will use text, cylinders, and spheres
	Eigen::Isometry3d text_pose = Eigen::Isometry3d::Identity();
	text_pose.translation().z() = 1.0;
	visual_tools.publishText(text_pose, "MoveGroupInterface Demo", rvt::WHITE, rvt::XLARGE);

	// Batch publishing is used to reduce the number of messages being sent to RViz for large visualizations
	visual_tools.trigger();

	//per visualizzare
	visual_tools.publishText(text_pose, "Add object", rvt::WHITE, rvt::XLARGE);
	visual_tools.trigger();

	return collision_object;
}

void openGripper(){
	moveit::planning_interface::MoveGroupInterface gripper_group("gripper");
	std::vector<double> gripper_open_position = {0.04, 0.04};
    gripper_group.setJointValueTarget(gripper_open_position);
	moveit::planning_interface::MoveGroupInterface::Plan my_planG;
	
	bool successG = (gripper_group.plan(my_planG) == moveit::planning_interface::MoveItErrorCode::SUCCESS);

    if (successG){
        ROS_INFO("Moving the gripper to the target pose");
		gripper_group.execute(my_planG);
        ROS_INFO("gripper movement completed");
    }
    else{
        ROS_ERROR("Failed to plan the gripper movement");
    }
}

void closeGripper(){
	moveit::planning_interface::MoveGroupInterface gripper_group("gripper");
	std::vector<double> gripper_close_position = {0.01, 0.01};
    gripper_group.setJointValueTarget(gripper_close_position);
	moveit::planning_interface::MoveGroupInterface::Plan my_planG1;
	
	bool successG = (gripper_group.plan(my_planG1) == moveit::planning_interface::MoveItErrorCode::SUCCESS);

    if (successG){
        ROS_INFO("Moving the gripper to the target pose");
		gripper_group.execute(my_planG1);
        ROS_INFO("gripper movement completed");
    }
    else{
        ROS_ERROR("Failed to plan the gripper movement");
    }
}

#include<unistd.h>    
void move_arm(float x, float y, float z, float rotation){

	sleep(10);

	// Create a MoveIt move group for the arm
	static const std::string PLANNING_GROUP = "arm";
    // The :planning_interface:`MoveGroupInterface` class can be easily
	// setup using just the name of the planning group you would like to control and plan for.
	moveit::planning_interface::MoveGroupInterface move_group_interface(PLANNING_GROUP);
	// We will use the :planning_interface:`PlanningSceneInterface`
	// class to add and remove collision objects in our "virtual world" scene
	moveit::planning_interface::PlanningSceneInterface planning_scene_interface;

	
	
	// Raw pointers are frequently used to refer to the planning group for improved performance.
	const moveit::core::JointModelGroup* joint_model_group =
		move_group_interface.getCurrentState()->getJointModelGroup(PLANNING_GROUP);

	// Getting Basic Information
	// We can print the name of the reference frame for this robot.
	ROS_INFO_NAMED("tutorial", "Planning frame: %s", move_group_interface.getPlanningFrame().c_str());

	// We can also print the name of the end-effector link for this group.
	ROS_INFO_NAMED("tutorial", "End effector link: %s", move_group_interface.getEndEffectorLink().c_str());

	// We can get a list of all the groups in the robot:
	ROS_INFO_NAMED("tutorial", "Available Planning Groups:");
	std::copy(move_group_interface.getJointModelGroupNames().begin(),
				move_group_interface.getJointModelGroupNames().end(), std::ostream_iterator<std::string>(std::cout, ", "));

    // Set the planner and planning attempts
    //move_group_interface.setPlannerId("RRTConnectkConfigDefault");
    //move_group_interface.setPlanningTime(50.0);
    //move_group_interface.setNumPlanningAttempts(10);
	
    // Set the target pose for the end-effector
    geometry_msgs::Pose target_pose;
	geometry_msgs::Quaternion quat_final = geometry_msgs::Quaternion();

	tf2::Quaternion q_x1 =tf2::Quaternion(tf2::Vector3(1, 0, 0), -M_PI/2);
	tf2::Quaternion q_z2 =tf2::Quaternion(tf2::Vector3(0, 0, 1), M_PI/2);
	tf2::Quaternion q_x3 =tf2::Quaternion(tf2::Vector3(1, 0, 0), rotation);

	tf2::Quaternion q = (q_x1*q_z2)*q_x3;

	quat_final.x = q.getX();
	quat_final.y = q.getY();
	quat_final.z = q.getZ();
	quat_final.w = q.getW();
    target_pose.orientation = quat_final;
    target_pose.position.x = x;
    target_pose.position.y = y;
    target_pose.position.z = z;
    move_group_interface.setPoseTarget(target_pose, "gripper_grasping_frame");
	

	openGripper();
	
	/*----------------------------------ATTENZIONE---------------------------------------------*/
	moveit_msgs::CollisionObject co=addCollision(0.45, 0, 0.15, 0, move_group_interface, planning_scene_interface); //POSIZIONE TEMPORANEA SOLO PER TESTARE
	/*-------------------------------FINE ATTENZIONE------------------------------------------*/

	// Plan the trajectory
    moveit::planning_interface::MoveGroupInterface::Plan my_plan;
	

	//------------------------------------------------
	/*
	bool success=(move_group_interface.pick("box0",false)== moveit::planning_interface::MoveItErrorCode::SUCCESS);
	if (success){
        // Execute the planned trajectory
        ROS_INFO("YEEEEEEEEEEEEEEEEEEEEEEEee");
    }
	else{
		ROS_INFO("NIoooooooooooooooooooooOO");
	}
	*/
	//------------------------------------------------
	
	//visual_tools.publishTrajectoryLine(myplan.trajectory, joint_model_group);
	//visual_tools.trigger();
	//visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window once the plan is complete");

    
    //moveit::core::MoveItErrorCode success = move_group.plan(my_plan);
	
	
	bool success = (move_group_interface.plan(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);
	
    if (success){
        // Execute the planned trajectory
        ROS_INFO("Moving the arm to the target pose");
        bool move_done=(move_group_interface.move() == moveit::core::MoveItErrorCode::SUCCESS);
		ROS_INFO("movimento braccio???: %d", move_done);
        ROS_INFO("Arm movement completed");
    }
    else{
        ROS_ERROR("Failed to plan the arm movement");
    }
	
	

	ROS_INFO_NAMED("tutorial", "Attach the object to the robot");
	move_group_interface.attachObject(co.id, "arm_tool_link", { "gripper_left", "gripper_right" });

	//visual_tools.publishText(text_pose, "Object attached to robot", rvt::WHITE, rvt::XLARGE);
	//visual_tools.trigger();

	//Replan, but now with the object in hand.

	move_group_interface.setStartStateToCurrentState();
	bool success0 = (move_group_interface.plan(my_plan) == moveit::core::MoveItErrorCode::SUCCESS);
	ROS_INFO_NAMED("tutorial", "Visualizing plan 7 (move around cuboid with cylinder) %s", success0 ? "" : "FAILED");

	closeGripper();
	ROS_INFO("MISSIONE COMPIUTA");

}

int main(int argc, char **argv){
	std::string name;
	if (argc < 2){
        ROS_INFO("Usage: $ rosrun ir2324_group_40_a2 node_a <node_a name [string]>");
		ROS_INFO("<node_a name> is the string that gives this node it's name");
		return 1;
	}else{
		name = argv[1];
	}

	ros::init(argc, argv, name);
	ros::NodeHandle n;

	ros::AsyncSpinner spinner(1);
	spinner.start();
	
	ros::ServiceClient positions_client = n.serviceClient<ir2324_group_40_a2::positions>("pickup_coords");

	//trick to make sure the robot doesn't get stuck in the first pilalr
	move_arm(0.45, 0, 0.25, 0.0);
	//move( 8.8, -0.3, -M_PI/2);	

	for(int i = 0; i < 3; i++){
		//PARTE 1: navigare davanti al tavolo
		//move( 1, 0, M_PI);

		//PARTE 2: richiesta blocchi
		int block_id=callHuman(n);
		move( X_[block_id], Y_[block_id], A_[block_id]);

		//PARTE 3: muoere testa e calcolre posiozione da assumere nel punto 4
		ir2324_group_40_a2::positions positions_srv;
		positions_srv.request.ID = (uint8_t)block_id;
		if(positions_client.call(positions_srv)){
			ROS_INFO("Target object coordinates recived");
			//se volete le coordinate sono in positions_srv.response
		}else{
			ROS_ERROR("FAILED TO GET OBJECT COORDINATES");
			return 1;
		}

		//PARTE 4: navigazione al blocco

		//PARTE 5: muovere il braccio e prendere il blocco

		//PARTE 6: trasportare il blocco al pilastro giusto

		//PARTE 7: lasciare il blocco al suo posto
	}

	

	return 0;
}
